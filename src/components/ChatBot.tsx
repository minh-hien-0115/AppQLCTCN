import React, { useState, useRef, useEffect } from 'react';
import { View, TextInput, StyleSheet, Text, FlatList, KeyboardAvoidingView, Platform, Alert, TouchableOpacity } from 'react-native';
import { chatWithGemini } from '../api/GeminiAPI';
import firestore, { FirebaseFirestoreTypes } from '@react-native-firebase/firestore';
import auth from '@react-native-firebase/auth';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

interface Message {
  id: string;
  sender: 'user' | 'bot';
  text: string;
  timestamp: FirebaseFirestoreTypes.FieldValue | Date;
}

const SYSTEM_PROMPT = `
B·∫°n l√† m·ªôt tr·ª£ l√Ω ·∫£o qu·∫£n l√Ω chi ti√™u c√° nh√¢n, th√¢n thi·ªán, d√≠ d·ªèm, v√† lu√¥n tr·∫£ l·ªùi t·ª± nhi√™n nh∆∞ m·ªôt ng∆∞·ªùi b·∫°n.
N·∫øu ng∆∞·ªùi d√πng y√™u c·∫ßu t·∫°o v√≠, th√™m giao d·ªãch, ho·∫∑c th·ªëng k√™, h√£y tr·∫£ v·ªÅ m·ªôt JSON h·ª£p l·ªá, KH√îNG k√®m b·∫•t k·ª≥ vƒÉn b·∫£n n√†o kh√°c, ch·ªâ tr·∫£ v·ªÅ JSON.
N·∫øu kh√¥ng ph·∫£i c√°c thao t√°c tr√™n, h√£y tr·∫£ l·ªùi NG·∫ÆN G·ªåN (ch·ªâ 1-2 c√¢u), s√∫c t√≠ch, th√¢n thi·ªán, d√≠ d·ªèm, kh√¥ng d√†i d√≤ng, kh√¥ng k·ªÉ chuy·ªán, kh√¥ng h·ªèi l·∫°i, kh√¥ng gi·∫£i th√≠ch, kh√¥ng th√™m l·ªùi khuy√™n, kh√¥ng d√πng emoji qu√° nhi·ªÅu.

C·∫•u tr√∫c JSON:
- T·∫°o v√≠: { "action": "create_wallet", "name": "T√™n v√≠", "currency": "VND", "balance": 0 }
- Th√™m giao d·ªãch: { "action": "add_transaction", "wallet": "T√™n v√≠", "type": "income|expense", "amount": s·ªë ti·ªÅn, "category": "T√™n kho·∫£n chi", "note": "Ghi ch√∫", "date": "yyyy-MM-dd" }
- N·∫øu ng∆∞·ªùi d√πng kh√¥ng ch·ªâ ƒë·ªãnh v√≠, h√£y d√πng v√≠ g·∫ßn nh·∫•t ho·∫∑c v√≠ v·ª´a ƒë∆∞·ª£c nh·∫Øc ƒë·∫øn trong h·ªôi tho·∫°i. N·∫øu kh√¥ng c√≥ v√≠ n√†o, y√™u c·∫ßu t·∫°o v√≠ tr∆∞·ªõc.
- Th·ªëng k√™: { "action": "statistic", "type": "expense|income|all", "period": "today|week|month" }

L∆∞u √Ω:
- N·∫øu h·ªôi tho·∫°i tr∆∞·ªõc ƒë√£ ƒë·ªÅ c·∫≠p ƒë·∫øn v√≠ ho·∫∑c lo·∫°i giao d·ªãch, h√£y t·ª± ƒë·ªông s·ª≠ d·ª•ng th√¥ng tin ƒë√≥, kh√¥ng h·ªèi l·∫°i ng∆∞·ªùi d√πng.
- N·∫øu thi·∫øu th√¥ng tin, h√£y c·ªë g·∫Øng suy lu·∫≠n t·ª´ l·ªãch s·ª≠ h·ªôi tho·∫°i, ch·ªâ h·ªèi l·∫°i khi th·ª±c s·ª± kh√¥ng th·ªÉ x√°c ƒë·ªãnh.
- Khi ng∆∞·ªùi d√πng y√™u c·∫ßu th√™m kho·∫£n chi ho·∫∑c kho·∫£n thu m√† kh√¥ng ch·ªâ ƒë·ªãnh v√≠, h√£y d√πng v√≠ g·∫ßn nh·∫•t ho·∫∑c v√≠ v·ª´a ƒë∆∞·ª£c nh·∫Øc ƒë·∫øn trong h·ªôi tho·∫°i.
- N·∫øu ng∆∞·ªùi d√πng h·ªèi v·ªÅ c√°c kho·∫£n chi, kho·∫£n thu, ho·∫∑c y√™u c·∫ßu li·ªát k√™, h√£y tr·∫£ v·ªÅ danh s√°ch t·ª´ng kho·∫£n chi/thu (danh m·ª•c, s·ªë ti·ªÅn, ghi ch√∫, ng√†y) trong kho·∫£ng th·ªùi gian t∆∞∆°ng ·ª©ng, kh√¥ng ch·ªâ tr·∫£ v·ªÅ t·ªïng s·ªë ti·ªÅn.
- N·∫øu thi·∫øu th√¥ng tin v·ªÅ v√≠ ho·∫∑c th·ªùi gian, h√£y t·ª± ƒë·ªông ch·ªçn v√≠ g·∫ßn nh·∫•t v√† th·ªùi gian l√† h√¥m nay, tr·ª´ khi h·ªôi tho·∫°i tr∆∞·ªõc c√≥ nh·∫Øc ƒë·∫øn.
- Khi tr·∫£ l·ªùi ng∆∞·ªùi d√πng (t·∫°o v√≠, th√™m giao d·ªãch, th·ªëng k√™, ho·∫∑c tr·∫£ l·ªùi th√¥ng th∆∞·ªùng), h√£y tr·∫£ l·ªùi d√≠ d·ªèm, vui v·∫ª, th√¢n thi·ªán, NG·∫ÆN G·ªåN (ch·ªâ 1-2 c√¢u), kh√¥ng d√†i d√≤ng, kh√¥ng k·ªÉ chuy·ªán, kh√¥ng h·ªèi l·∫°i, kh√¥ng gi·∫£i th√≠ch, kh√¥ng th√™m l·ªùi khuy√™n, kh√¥ng d√πng emoji qu√° nhi·ªÅu.
`;

const BOT_INTRO = 'Xin ch√†o! T√¥i l√† qu·∫£n tr·ªã vi√™n qu·∫£n l√Ω chi ti√™u c√° nh√¢n c·ªßa b·∫°n!';

// H√†m sinh c√¢u tr·∫£ l·ªùi t·ª± nhi√™n, th√¢n thi·ªán
function generateNaturalReply(type: string, data: any): string {
  switch (type) {
    case 'success_create_wallet':
      return `üéâ V√≠ '${data.name}' ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng! Ch√∫c b·∫°n qu·∫£n l√Ω chi ti√™u th·∫≠t t·ªët nh√©!`;
    case 'fail_create_wallet':
      return `üò¢ Xin l·ªói, kh√¥ng th·ªÉ t·∫°o v√≠ m·ªõi l√∫c n√†y. B·∫°n th·ª≠ l·∫°i sau nh√©!`;
    case 'success_add_transaction':
      return `ƒê√£ ghi nh·∫≠n giao d·ªãch ${data.amount.toLocaleString()} cho ${data.category} v√†o v√≠ '${data.wallet}'. B·∫°n nh·ªõ ki·ªÉm so√°t chi ti√™u nh√©!`;
    case 'fail_add_transaction':
      return `Kh√¥ng th·ªÉ th√™m giao d·ªãch. B·∫°n ki·ªÉm tra l·∫°i th√¥ng tin ho·∫∑c th·ª≠ l·∫°i sau nh√©!`;
    case 'success_statistic':
      return `T·ªïng ${data.type === 'income' ? 'thu nh·∫≠p' : data.type === 'expense' ? 'chi ti√™u' : 'giao d·ªãch'} ${data.period === 'today' ? 'h√¥m nay' : data.period === 'week' ? 'tu·∫ßn n√†y' : data.period === 'month' ? 'th√°ng n√†y' : ''}: ${data.total.toLocaleString()} ƒë. C·ªë g·∫Øng ti·∫øt ki·ªám h∆°n nh√©!`;
    case 'fail_statistic':
      return `Kh√¥ng th·ªÉ th·ªëng k√™ l√∫c n√†y. B·∫°n th·ª≠ l·∫°i sau nh√©!`;
    default:
      return 'Thao t√°c th√†nh c√¥ng!';
  }
}

// H√†m build prompt h·ªôi tho·∫°i v·ªõi l·ªãch s·ª≠ 50 c√¢u g·∫ßn nh·∫•t
function buildConversationPrompt(messages: Message[], systemPrompt: string, userMsg: string) {
  let history = messages
    .slice(-50)
    .map(m => (m.sender === 'user' ? `Ng∆∞·ªùi d√πng: ${m.text}` : `Bot: ${m.text}`))
    .join('\n');
  return `${systemPrompt}\n\nL·ªãch s·ª≠ h·ªôi tho·∫°i:\n${history}\nNg∆∞·ªùi d√πng: ${userMsg}`;
}

const ChatBot: React.FC = () => {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [loading, setLoading] = useState(false);
  const [lastWallet, setLastWallet] = useState<string | null>(null);
  const [wallets, setWallets] = useState<any[]>([]);
  const flatListRef = useRef<FlatList>(null);
  const user = auth().currentUser;

  // Load chat history when component mounts
  useEffect(() => {
    if (!user) return;

    const loadChatHistory = async () => {
      try {
        const chatRef = firestore()
          .collection('users')
          .doc(user.uid)
          .collection('chat_history')
          .orderBy('timestamp', 'asc');

        const unsubscribe = chatRef.onSnapshot(snapshot => {
          if (snapshot.empty) {
            // N·∫øu ch∆∞a c√≥ tin nh·∫Øn n√†o, th√™m tin nh·∫Øn ch√†o m·ª´ng
            const welcomeMsg: Message = {
              id: `bot_${Date.now()}`,
              sender: 'bot',
              text: BOT_INTRO,
              timestamp: firestore.FieldValue.serverTimestamp()
            };
            saveMessage(welcomeMsg);
            setMessages([welcomeMsg]);
          } else {
            const loadedMessages: Message[] = [];
            snapshot.forEach(doc => {
              loadedMessages.push(doc.data() as Message);
            });
            setMessages(loadedMessages);
          }
        });

        return unsubscribe;
      } catch (error) {
        console.error('Error loading chat history:', error);
        // N·∫øu c√≥ l·ªói, v·∫´n hi·ªÉn th·ªã tin nh·∫Øn ch√†o m·ª´ng
        const welcomeMsg: Message = {
          id: `bot_${Date.now()}`,
          sender: 'bot',
          text: BOT_INTRO,
          timestamp: firestore.FieldValue.serverTimestamp()
        };
        setMessages([welcomeMsg]);
        saveMessage(welcomeMsg);
      }
    };

    loadChatHistory();
  }, [user]);

  // Qu√©t danh s√°ch v√≠ khi m·ªü ChatBot (realtime)
  useEffect(() => {
    if (!user) return;
    const unsubscribe = firestore()
      .collection('users')
      .doc(user.uid)
      .collection('wallets')
      .onSnapshot(snap => {
        const walletList = snap.docs.map(doc => ({ id: doc.id, ...(doc.data() as any) }));
        setWallets(walletList);
        if (walletList.length > 0 && walletList[0].name) {
          setLastWallet(walletList[0].name);
        } else {
          setLastWallet(null);
        }
      });
    return () => unsubscribe();
  }, [user]);

  // Save message to Firestore
  const saveMessage = async (message: Message) => {
    if (!user) return;

    try {
      await firestore()
        .collection('users')
        .doc(user.uid)
        .collection('chat_history')
        .doc(message.id)
        .set(message);
    } catch (error) {
      console.error('Error saving message:', error);
    }
  };

  // X·ª≠ l√Ω l·ªánh JSON t·ª´ bot
  const handleBotCommand = async (json: any) => {
    if (!user) {
      const errorMsg: Message = { 
        id: `bot_${Date.now()}`,
        sender: 'bot', 
        text: 'B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p.', 
        timestamp: firestore.FieldValue.serverTimestamp() 
      };
      setMessages(prev => [...prev, errorMsg]);
      await saveMessage(errorMsg);
      return;
    }

    const userId = user.uid;
    if (json.action === 'create_wallet') {
      try {
        const newWalletRef = firestore()
          .collection('users')
          .doc(userId)
          .collection('wallets')
          .doc();
        await newWalletRef.set({
          id: newWalletRef.id,
          name: json.name,
          currency: json.currency || 'VND',
          balance: json.balance || 0,
          createdAt: firestore.FieldValue.serverTimestamp(),
        });
        setLastWallet(json.name);
        // G·ª≠i prompt cho Gemini ƒë·ªÉ tr·∫£ l·ªùi t·ª± nhi√™n
        const resultPrompt = `T√¥i v·ª´a t·∫°o v√≠ th√†nh c√¥ng v·ªõi t√™n '${json.name}'. H√£y tr·∫£ l·ªùi ng∆∞·ªùi d√πng m·ªôt c√°ch th√¢n thi·ªán, t·ª± nhi√™n, vui v·∫ª nh∆∞ m·ªôt tr·ª£ l√Ω AI.`;
        const prompt = buildConversationPrompt(messages, '', resultPrompt);
        const aiReply = await chatWithGemini(prompt);
        const successMsg: Message = { 
          id: `bot_${Date.now()}`,
          sender: 'bot', 
          text: aiReply, 
          timestamp: firestore.FieldValue.serverTimestamp() 
        };
        setMessages(prev => [...prev, successMsg]);
        await saveMessage(successMsg);
      } catch (e) {
        const resultPrompt = `T√¥i v·ª´a th·ª±c hi·ªán thao t√°c t·∫°o v√≠ nh∆∞ng b·ªã l·ªói. H√£y tr·∫£ l·ªùi ng∆∞·ªùi d√πng m·ªôt c√°ch th√¢n thi·ªán, t·ª± nhi√™n, vui v·∫ª nh∆∞ m·ªôt tr·ª£ l√Ω AI.`;
        const prompt = buildConversationPrompt(messages, '', resultPrompt);
        const aiReply = await chatWithGemini(prompt);
        const errorMsg: Message = { 
          id: `bot_${Date.now()}`,
          sender: 'bot', 
          text: aiReply, 
          timestamp: firestore.FieldValue.serverTimestamp() 
        };
        setMessages(prev => [...prev, errorMsg]);
        await saveMessage(errorMsg);
      }
    } else if (json.action === 'add_transaction') {
      try {
        let walletName = json.wallet || lastWallet;
        if (!walletName || walletName.toLowerCase().includes('g·∫ßn nh·∫•t')) {
          const walletsSnap = await firestore()
            .collection('users')
            .doc(userId)
            .collection('wallets')
            .get();
          const wallets = walletsSnap.docs.map(doc => doc.data().name.toLowerCase());
          let matchedWallet = null;
          if (json.category) {
            matchedWallet = wallets.find(name => json.category.toLowerCase().includes(name));
          }
          if (!matchedWallet && json.note) {
            matchedWallet = wallets.find(name => json.note.toLowerCase().includes(name));
          }
          walletName = matchedWallet || (walletsSnap.size > 0 ? walletsSnap.docs[0].data().name : null);
          setLastWallet(walletName);
        }
        if (!walletName) {
          const errorMsg: Message = { 
            id: `bot_${Date.now()}`,
            sender: 'bot', 
            text: 'B·∫°n ch∆∞a c√≥ v√≠ n√†o, h√£y t·∫°o v√≠ tr∆∞·ªõc nh√©!', 
            timestamp: firestore.FieldValue.serverTimestamp() 
          };
          setMessages(prev => [...prev, errorMsg]);
          await saveMessage(errorMsg);
          return;
        }
        const walletSnap = await firestore()
          .collection('users')
          .doc(userId)
          .collection('wallets')
          .where('name', '==', walletName)
          .get();
        if (walletSnap.empty) {
          const errorMsg: Message = { 
            id: `bot_${Date.now()}`,
            sender: 'bot', 
            text: `Kh√¥ng t√¨m th·∫•y v√≠ t√™n "${walletName}".`, 
            timestamp: firestore.FieldValue.serverTimestamp() 
          };
          setMessages(prev => [...prev, errorMsg]);
          await saveMessage(errorMsg);
          return;
        }
        const walletDoc = walletSnap.docs[0];
        const walletId = walletDoc.id;
        const walletData = walletDoc.data();
        const amount = Number(json.amount);
        const type = json.type;
        const newBalance = type === 'income' ? walletData.balance + amount : walletData.balance - amount;
        await firestore()
          .collection('users')
          .doc(userId)
          .collection('wallets')
          .doc(walletId)
          .collection('transactions')
          .add({
            type,
            category: json.category,
            amount,
            note: json.note || '',
            createdAt: firestore.FieldValue.serverTimestamp(),
            date: json.date || new Date().toISOString().slice(0, 10),
          });
        await firestore()
          .collection('users')
          .doc(userId)
          .collection('wallets')
          .doc(walletId)
          .update({ balance: newBalance });
        setLastWallet(walletName);
        // G·ª≠i prompt cho Gemini ƒë·ªÉ tr·∫£ l·ªùi t·ª± nhi√™n
        const resultPrompt = `T√¥i v·ª´a th√™m giao d·ªãch th√†nh c√¥ng: ${type === 'income' ? 'thu nh·∫≠p' : 'chi ti√™u'} ${amount.toLocaleString()} cho ${json.category} v√†o v√≠ '${walletName}'. H√£y tr·∫£ l·ªùi ng∆∞·ªùi d√πng m·ªôt c√°ch th√¢n thi·ªán, t·ª± nhi√™n, vui v·∫ª nh∆∞ m·ªôt tr·ª£ l√Ω AI.`;
        const prompt = buildConversationPrompt(messages, '', resultPrompt);
        const aiReply = await chatWithGemini(prompt);
        const successMsg: Message = { 
          id: `bot_${Date.now()}`,
          sender: 'bot', 
          text: aiReply, 
          timestamp: firestore.FieldValue.serverTimestamp() 
        };
        setMessages(prev => [...prev, successMsg]);
        await saveMessage(successMsg);
      } catch (e) {
        const resultPrompt = `T√¥i v·ª´a th·ª±c hi·ªán thao t√°c th√™m giao d·ªãch nh∆∞ng b·ªã l·ªói. H√£y tr·∫£ l·ªùi ng∆∞·ªùi d√πng m·ªôt c√°ch th√¢n thi·ªán, t·ª± nhi√™n, vui v·∫ª nh∆∞ m·ªôt tr·ª£ l√Ω AI.`;
        const prompt = buildConversationPrompt(messages, '', resultPrompt);
        const aiReply = await chatWithGemini(prompt);
        const errorMsg: Message = { 
          id: `bot_${Date.now()}`,
          sender: 'bot', 
          text: aiReply, 
          timestamp: firestore.FieldValue.serverTimestamp() 
        };
        setMessages(prev => [...prev, errorMsg]);
        await saveMessage(errorMsg);
      }
    } else if (json.action === 'statistic') {
      try {
        const walletsSnap = await firestore()
          .collection('users')
          .doc(userId)
          .collection('wallets')
          .get();
        let total = 0;
        let type = json.type;
        let period = json.period;
        let now = new Date();
        const items: any[] = [];
        for (const walletDoc of walletsSnap.docs) {
          const transSnap = await firestore()
            .collection('users')
            .doc(userId)
            .collection('wallets')
            .doc(walletDoc.id)
            .collection('transactions')
            .get();
          for (const t of transSnap.docs) {
            const data = t.data();
            let match = true;
            if (type !== 'all' && data.type !== type) match = false;
            if (period === 'today') {
              const d = data.createdAt?.toDate?.() || new Date(data.createdAt);
              if (d.toDateString() !== now.toDateString()) match = false;
            }
            if (match) {
              total += Number(data.amount);
              items.push({
                category: data.category,
                amount: data.amount,
                note: data.note,
                date: data.date,
                type: data.type,
                wallet: walletDoc.data().name
              });
            }
          }
        }
        // G·ª≠i danh s√°ch items cho Gemini ƒë·ªÉ tr·∫£ l·ªùi t·ª± nhi√™n
        const resultPrompt = `H√£y li·ªát k√™ c√°c kho·∫£n ${type === 'income' ? 'thu nh·∫≠p' : type === 'expense' ? 'chi ti√™u' : 'giao d·ªãch'} ${period === 'today' ? 'h√¥m nay' : period === 'week' ? 'tu·∫ßn n√†y' : period === 'month' ? 'th√°ng n√†y' : ''} v·ªõi d·ªØ li·ªáu sau: ${JSON.stringify(items)}. Tr·∫£ l·ªùi NG·∫ÆN G·ªåN (ch·ªâ 1-2 c√¢u), s√∫c t√≠ch, th√¢n thi·ªán, d√≠ d·ªèm, kh√¥ng d√†i d√≤ng, kh√¥ng k·ªÉ chuy·ªán, kh√¥ng h·ªèi l·∫°i, kh√¥ng gi·∫£i th√≠ch, kh√¥ng th√™m l·ªùi khuy√™n, kh√¥ng d√πng emoji qu√° nhi·ªÅu.`;
        const prompt = buildConversationPrompt(messages, '', resultPrompt);
        const aiReply = await chatWithGemini(prompt);
        const successMsg: Message = { 
          id: `bot_${Date.now()}`,
          sender: 'bot', 
          text: aiReply, 
          timestamp: firestore.FieldValue.serverTimestamp() 
        };
        setMessages(prev => [...prev, successMsg]);
        await saveMessage(successMsg);
      } catch (e) {
        const resultPrompt = `T√¥i v·ª´a th·ª±c hi·ªán thao t√°c th·ªëng k√™ nh∆∞ng b·ªã l·ªói. H√£y tr·∫£ l·ªùi ng∆∞·ªùi d√πng m·ªôt c√°ch th√¢n thi·ªán, t·ª± nhi√™n, vui v·∫ª nh∆∞ m·ªôt tr·ª£ l√Ω AI.`;
        const prompt = buildConversationPrompt(messages, '', resultPrompt);
        const aiReply = await chatWithGemini(prompt);
        const errorMsg: Message = { 
          id: `bot_${Date.now()}`,
          sender: 'bot', 
          text: aiReply, 
          timestamp: firestore.FieldValue.serverTimestamp() 
        };
        setMessages(prev => [...prev, errorMsg]);
        await saveMessage(errorMsg);
      }
    } else {
      const errorMsg: Message = { 
        id: `bot_${Date.now()}`,
        sender: 'bot', 
        text: 'L·ªánh kh√¥ng h·ª£p l·ªá ho·∫∑c ch∆∞a h·ªó tr·ª£.', 
        timestamp: firestore.FieldValue.serverTimestamp() 
      };
      setMessages(prev => [...prev, errorMsg]);
      await saveMessage(errorMsg);
    }
  };

  const handleSend = async () => {
    if (!message.trim() || !user) return;

    const userMsg: Message = { 
      id: `user_${Date.now()}`,
      sender: 'user', 
      text: message,
      timestamp: firestore.FieldValue.serverTimestamp()
    };
    
    setMessages(prev => [...prev, userMsg]);
    await saveMessage(userMsg);
    setMessage('');
    setLoading(true);

    try {
      const prompt = buildConversationPrompt([...messages, userMsg], SYSTEM_PROMPT, userMsg.text);
      const reply = await chatWithGemini(prompt);
      let jsonStr = reply;
      const codeBlockMatch = reply.match(/```json([\s\S]*?)```|```([\s\S]*?)```/);
      if (codeBlockMatch) {
        jsonStr = codeBlockMatch[1] || codeBlockMatch[2] || '';
      }
      jsonStr = jsonStr.trim().replace(/^([^{]*)/, '').replace(/([^}]*)$/, '');
      let parsed;
      try {
        parsed = JSON.parse(jsonStr);
      } catch {
        parsed = null;
      }

      // N·∫øu l√† th·ªëng k√™ nh∆∞ng kh√¥ng parse ƒë∆∞·ª£c JSON, v·∫´n hi·ªÉn th·ªã text tr·∫£ v·ªÅ
      if (parsed && parsed.action) {
        await handleBotCommand(parsed);
      } else {
        // N·∫øu ng∆∞·ªùi d√πng h·ªèi v·ªÅ th·ªëng k√™ nh∆∞ng Gemini tr·∫£ v·ªÅ text th∆∞·ªùng
        if (/th·ªëng k√™|t·ªïng thu|t·ªïng chi|bao nhi√™u|chi ti√™u|thu nh·∫≠p/i.test(userMsg.text)) {
          const botMsg: Message = {
            id: `bot_${Date.now()}`,
            sender: 'bot',
            text: reply,
            timestamp: firestore.FieldValue.serverTimestamp()
          };
          setMessages(prev => [...prev, botMsg]);
          await saveMessage(botMsg);
        } else if (jsonStr.includes('{') && jsonStr.includes('}')) {
          const errorMsg: Message = {
            id: `bot_${Date.now()}`,
            sender: 'bot',
            text: 'Xin l·ªói, t√¥i ch∆∞a hi·ªÉu y√™u c·∫ßu ho·∫∑c thao t√°c n√†y. B·∫°n c√≥ th·ªÉ th·ª≠ l·∫°i ho·∫∑c n√≥i r√µ h∆°n nh√©!',
            timestamp: firestore.FieldValue.serverTimestamp()
          };
          setMessages(prev => [...prev, errorMsg]);
          await saveMessage(errorMsg);
        } else {
          const botMsg: Message = {
            id: `bot_${Date.now()}`,
            sender: 'bot',
            text: reply,
            timestamp: firestore.FieldValue.serverTimestamp()
          };
          setMessages(prev => [...prev, botMsg]);
          await saveMessage(botMsg);
        }
      }
    } catch {
      const errorMsg: Message = {
        id: `bot_${Date.now()}`,
        sender: 'bot',
        text: 'C√≥ l·ªói x·∫£y ra khi g·ªçi API.',
        timestamp: firestore.FieldValue.serverTimestamp()
      };
      setMessages(prev => [...prev, errorMsg]);
      await saveMessage(errorMsg);
    }
    
    setLoading(false);
    setTimeout(() => flatListRef.current?.scrollToEnd({ animated: true }), 100);
  };

  const renderItem = ({ item }: { item: Message }) => (
    <View style={[styles.bubble, item.sender === 'user' ? styles.userBubble : styles.botBubble]}>
      <Text style={item.sender === 'user' ? styles.userText : styles.botText}>{item.text}</Text>
    </View>
  );

  return (
    <KeyboardAvoidingView style={styles.container} behavior={Platform.OS === 'ios' ? 'padding' : undefined}>
      <FlatList
        ref={flatListRef}
        data={messages}
        renderItem={renderItem}
        keyExtractor={(_, idx) => idx.toString()}
        contentContainerStyle={styles.chatArea}
        onContentSizeChange={() => flatListRef.current?.scrollToEnd({ animated: true })}
      />
      <View style={styles.inputRow}>
        <TextInput
          style={styles.input}
          value={message}
          onChangeText={setMessage}
          placeholder="Nh·∫≠p tin nh·∫Øn..."
          editable={!loading}
          autoCapitalize="none"
          autoCorrect={false}
          textContentType="none"
          autoComplete="off"
          spellCheck={false}
          multiline={true}
          maxLength={1000}
          blurOnSubmit={false}
          returnKeyType="send"
          onSubmitEditing={handleSend}
        />
        <TouchableOpacity
          style={styles.sendButton}
          onPress={handleSend}
          disabled={loading || !message.trim()}
        >
          <Icon name="send" size={24} color="#fff" />
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f0f0f0',
    borderRadius: 10,
    margin: 0,
    padding: 0,
  },
  chatArea: {
    padding: 16,
    paddingBottom: 0,
  },
  inputRow: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 10,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderColor: '#eee',
  },
  input: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 10,
    borderRadius: 20,
    marginRight: 10,
    backgroundColor: '#fff',
    maxHeight: 100,
  },
  sendButton: {
    width: 44,
    height: 44,
    borderRadius: 12,
    backgroundColor: '#2196f3',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 8,
    elevation: 2,
    shadowColor: '#2196f3',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
  },
  bubble: {
    maxWidth: '80%',
    padding: 10,
    borderRadius: 16,
    marginBottom: 10,
  },
  userBubble: {
    backgroundColor: '#1976d2',
    alignSelf: 'flex-end',
    borderBottomRightRadius: 4,
  },
  botBubble: {
    backgroundColor: '#fff',
    alignSelf: 'flex-start',
    borderBottomLeftRadius: 4,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  userText: {
    color: '#fff',
  },
  botText: {
    color: '#333',
  },
});

export default ChatBot;
